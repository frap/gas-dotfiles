#+TITLE:  Emacs Configuration File
#+AUTHOR: Andrés Gasson
#+EMAIL:  agasson@red-elvis.net
#+DATE:   [2017-09-11 Mon]
* Introduction

  This is my =.emacs= file ... well, the top-level of it anyway.
  I've written it in a [[http://www.orgmode.org][literate style]], to make it easy to explain.
  Most of this is stolen from Howard Abrahms and Sasha Chua.
  The notes also include hyperlinks to where I stole it. ;-)

* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, Aquamacs
   overrides that hence the following new global variable for that:

   #+BEGIN_SRC elisp
     (defconst gas/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun gas/emacs-subdirectory (d) (expand-file-name d gas/emacs-directory))
   #+End_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   #+BEGIN_SRC elisp
     (let* ((subdirs '("elisp" "backups"))
            (fulldirs (mapcar (lambda (d) (gas/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Making directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customisation Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "custom.el" gas/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

   #+BEGIN_SRC elisp
     (add-to-list 'load-path (gas/emacs-subdirectory "elisp"))
   #+END_SRC

** Modernising Emacs

   With a long history of working on small machines without gigabytes
   of RAM, we might as well let Emacs be the beast it has always
   dreamed.

   First, let’s increase the cache before starting garbage collection:
   #+BEGIN_SRC elisp
     (setq gc-cons-threshold 50000000)
   #+END_SRC

   Found [[https://github.com/wasamasa/dotemacs/blob/master/init.org#init][here]] how to remove the warnings from the GnuTLS library when
   using HTTPS... increase the minimum prime bits size:
   #+BEGIN_SRC elisp
     (setq gnutls-min-prime-bits 4096)
   #+END_SRC

* Package Initialisation
** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories.

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                                  ("gnu"       . "http://elpa.gnu.org/packages/")
                                  ("melpa"     . "http://melpa.org/packages/")
                                  ("marmalade" . "http://marmalade-repo.org/packages/")))

     (package-initialize)
     (package-refresh-contents)

     (defalias 'pi 'package-install)
     (defalias 'pl 'package-list-packages)
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

* Variables

  General settings about me that other packages can use. The biggest
  problem is guessing my email address based on what computer I am using:

  #+BEGIN_SRC elisp
    (if (equal "atearoot" user-login-name)
        (setq user-mail-address "agasson@ateasystems.com")
      (setq user-mail-address "agasson@red-elvis.net"))
  #+END_SRC

** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** Encrypting Files

   Synchronise notes formatted in org-mode across multiple computers
   with cloud storage services, like Dropbox? Those files are /cached/
   in various other storage facilities... so, I use symmetric key
   encryption with [[http://en.wikipedia.org/wiki/Pretty_Good_Privacy][PGP]].

   Now, any file loaded with a =gpg= extension, e.g. =some.org.gpg=,
   will prompt for a password (and then use =org-mode=).  Since these
   files are for my eyes only, I don’t need the key-ring prompt:

   #+BEGIN_SRC elisp
     (setq epa-file-select-keys 2)
   #+END_SRC

   If you trust your Emacs session on your computer, you can have
   Emacs cache the password.

   #+BEGIN_SRC elisp
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
   #+END_SRC

** Misc Variable Settings

   Does anyone type =yes= anymore?
   #+BEGIN_SRC elisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Fix the scrolling to keep point in the center:
   #+BEGIN_SRC elisp
     (setq scroll-conservatively 10000
           scroll-preserve-screen-position t)
   #+END_SRC

   I've been using Emacs for too long to need to re-enable each
   feature bit-by-bit:
   #+BEGIN_SRC elisp
     (setq disabled-command-function nil)
   #+END_SRC

* Display

  Call my display settings file
  #+BEGIN_SRC elisp
    (require 'init-display)

(when is-mac
  ;; Change command to meta.
  (setq mac-command-modifier 'super)
  (setq mac-option-modifier 'meta)
  ;; not sure what hyper is (setq ns-function-modifier 'hyper)
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  ;; Use right option for special characters.
;;  (setq mac-right-option-modifier 'none)

  ;; Remove date and battery status from modeline
  (display-time-mode -1)
  (display-battery-mode -1)

  ;; Set paths to homebrew installed programs.
  (progn
    (setq-default ispell-program-name "/usr/local/bin/aspell"))

  ;; Evaluate Code Blocks on Remote Machines
  ;; http://howardism.org/Technical/Emacs/literate-devops.html#fn.2
  (defun org-babel-temp-file (prefix &optional suffix)
    "Create a temporary file in the `org-babel-temporary-directory'.
Passes PREFIX and SUFFIX directly to `make-temp-file' with the
value of `temporary-file-directory' temporarily set to the value
of `org-babel-temporary-directory'."
    (if (file-remote-p default-directory)
        (let ((prefix
               ;; We cannot use `temporary-file-directory' as local part
               ;; on the remote host, because it might be another OS
               ;; there.  So we assume "/tmp", which ought to exist on
               ;; relevant architectures.
               (concat (file-remote-p default-directory)
                       ;; REPLACE temporary-file-directory with /tmp:
                       (expand-file-name prefix "/tmp/"))))
          (make-temp-file prefix nil suffix))
      (let ((temporary-file-directory
             (or (and (boundp 'org-babel-temporary-directory)
                      (file-exists-p org-babel-temporary-directory)
                      org-babel-temporary-directory)
                 temporary-file-directory)))
        (make-temp-file prefix nil suffix)))))
  #+END_SRC

* Keybindings

  Call my display settings file
  #+BEGIN_SRC elisp
    (require 'init-keybindings)
  #+END_SRC

* Loading Files

   See [[file:emacs-file.org][emacs-files.el]] for details on working with File loading.

   #+BEGIN_SRC elisp
     (require 'init-files)
   #+END_SRC

* Word Smithing
   See [[file:emacs-wordsmithing.org][emacs-wordsmithing.el]] for details on word smithing and emacs.

   #+BEGIN_SRC elisp
     (require 'init-wordsmithing)
   #+END_SRC

* Programming Languages

** General Language Support

   Many programming language environments can benefit from this section.

*** ElDoc

    I like ElDoc support (when I can get it), but not needed in the
    mode line:

    #+BEGIN_SRC elisp
      (use-package eldoc
        :diminish eldoc-mode
        :init  (setq eldoc-idle-delay 0.1))
    #+END_SRC

*** Tag Support

   All programming languages require some sort of tagging. but after
   thirty years, we are still using good ol’ ctags...well,
   [[http://ctags.sourceforge.net][Exuberant Ctags]].   Install with Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install --HEAD ctags
   #+END_SRC

   On Ubuntu Linux, do:

   #+BEGIN_SRC sh :tangle no
     sudo apt-get install -y exuberant-ctags
   #+END_SRC

   Note: for every project, run the following command:

   #+BEGIN_SRC sh :tangle no
     ctags -e -R .
   #+END_SRC

   I want to be able to add headers from my =org-mode= files as
   a /language option/:

   #+BEGIN_SRC sh :tangle ~/.ctags :comments no
     --langdef=org
     --langmap=org:.org
     --regex-org=/^\*+[ \t]+([a-zA-Z0-9_ ]+)/\1/d,definition/

     --exclude=vendor
     --exclude=.git
   #+END_SRC

   We access stuff by loading the =etags= package:

   #+BEGIN_SRC elisp
     (use-package etags
        :init (setq tags-revert-without-query 1))
   #+END_SRC

   Now, use the following keys:

   - M-. :: To find the tag at point to jump to the function’s
            definition when the point is over a function call. It is a
            dwim-type function.
   - M-, :: jump back to where you were.
   - M-? :: find a tag, that is, use the Tags file to look up a
            definition. If there are multiple tags in the project with
            the same name, use `C-u M-.’ to go to the next match.
   - =M-x tags-search= :: regexp-search through the source files
        indexed by a tags file (a bit like =grep=)
   - =M-x tags-query-replace= :: query-replace through the source files
        indexed by a tags file
   - =M-x tags-apropos= :: list all tags in a tags file that match a
        regexp
   - =M-x list-tags= :: list all tags defined in a source file

   With the fancy new [[https://marmalade-repo.org/packages/ctags-update][ctags-update]] package, we can update the tags file
   whenever we save a file:

   #+BEGIN_SRC elisp :tangle no
     (use-package ctags-update
       :ensure t
       :config
       (add-hook 'prog-mode-hook  'turn-on-ctags-auto-update-mode)
       :diminish ctags-auto-update-mode)
   #+END_SRC

   While, I like =imenu=, [[https://github.com/vspinu/imenu-anywhere][combining it]] with an IDO interface nicely
   lists the headings/functions in the current buffer:

   #+BEGIN_SRC elisp
     (use-package idomenu
       :ensure t
       :bind ("C-c i" . idomenu))
   #+END_SRC

   If I don't know what I'm after, Helm is better:

   #+BEGIN_SRC elisp
     (use-package helm
       :bind (("C-c M-i" . helm-imenu)))
   #+END_SRC

   However, I need to use [[http://www.emacswiki.org/emacs/EtagsSelect#toc3][this function]] to use IDO in conjunctions
   with the TAGS file for all functions in the project:

   #+BEGIN_SRC elisp
     (use-package ido
       :config
       (defun ido-find-tag ()
         "Find a tag using ido"
         (interactive)
         (tags-completion-table)
         (let (tag-names)
           (mapatoms (lambda (x)
                       (push (prin1-to-string x t) tag-names))
                     tags-completion-table)
           (find-tag (ido-completing-read "Tag: " tag-names))))

       (global-set-key (kbd "C-c I") 'ido-find-tag))
   #+END_SRC

   Emacs 25 changed has now deprecated the famous [[info:emacs#Tags][Tags and Friends]],
   like =find-tags= for =xref=.

   Note: This prompt needs to go away:

   #+BEGIN_SRC elisp
     (setq tags-add-tables nil)
   #+END_SRC

   What if the marker stack is empty? M-, returns an error. Let's do a
   DWIM function:

   #+BEGIN_SRC elisp
     (defun ha/xref-pop-marker-stack (arg)
       "Pops the marker stack, unless I haven't searched a tag/xref
     with `M-.' and there is nothing to return to, in which case, let's
     jump back to the last change."
       (interactive "P")
       (condition-case nil
           (xref-pop-marker-stack)
         (error
          (goto-last-change arg))))

     (bind-key "M-," 'ha/xref-pop-marker-stack)
   #+END_SRC

*** Code Block Folding

    The [[info:emacs#Hideshow][Hide Show Minor]] mode allows us to /fold/ all functions
    (hidden), showing only the header lines. We need to turn on the
    mode, so wrappers are in order:

    #+BEGIN_SRC elisp
      (defun gas/hs-show-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-show-all))

      (defun gas/hs-hide-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-hide-all))

      (defun gas/hs-toggle-hiding ()
        (interactive)
        (hs-minor-mode 1)
        (hs-toggle-hiding))
    #+END_SRC

    Seems that =C-c @= is too obnoxious to use, so I'll put my
    favorite on the =C-c h= prefix:

    #+BEGIN_SRC elisp
      (use-package hs-minor-mode
        :bind
        ("C-c T h" . hs-minor-mode)
        ("C-c h a" . gas/hs-hide-all)
        ("C-c h s" . gas/hs-show-all)
        ("C-c h h" . gas/hs-toggle-hiding))
    #+END_SRC

    See the [[http://www.emacswiki.org/emacs/HideShow][online resources]].

*** Aggressive Auto Indention

    Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
    and seems to be quite helpful for many types of programming
    languages.

    To begin, we create a function that can indent a function by
    calling =indent-region= on the beginning and ending points of a
    function.

    #+BEGIN_SRC elisp
      (defun indent-defun ()
        "Indent current defun.
      Do nothing if mark is active (to avoid deactivaing it), or if
      buffer is not modified (to avoid creating accidental
      modifications)."
        (interactive)
        (unless (or (region-active-p)
                    buffer-read-only
                    (null (buffer-modified-p)))
          (let ((l (save-excursion (beginning-of-defun 1) (point)))
                (r (save-excursion (end-of-defun 1) (point))))
            (cl-letf (((symbol-function 'message) #'ignore))
              (indent-region l r)))))
    #+END_SRC

    Next, create a hook that will call the =indent-defun= with every
    command call:

    #+BEGIN_SRC elisp
      (defun activate-aggressive-indent ()
        "Locally add `gas/indent-defun' to `post-command-hook'."
        (add-hook 'post-command-hook
                  'indent-defun nil 'local))
    #+END_SRC

*** Red Warnings

    Various keywords (in comments) are now flagged in a Red Error font:

    #+BEGIN_SRC elisp
      (add-hook 'prog-common-hook
                (lambda ()
                  (font-lock-add-keywords nil
                                          '(("\\<\\(FIX\\|FIXME\\|TODO\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))))
    #+END_SRC

*** XML

    Can't believe we are still dealing with this awful data format.

    #+BEGIN_SRC elisp
      (setq nxml-slash-auto-complete-flag t)
    #+END_SRC

    Remember a couple of bindings:

    - ~C-c C-i~ :: Type =<p= and then this, to have the other tag inserted
         and the cursor in the middle.
    - ~C-c C-f~ :: Finish any opened tag that needs to be completed.
    - ~C-c C-s C-a~ :: After putting in the schema, use this to refresh it

** Shell Scripts

   Files in my =bin= directory (but /only/ if it doesn't have any
   other extension), should start in =sh-mode=:

   #+BEGIN_SRC elisp
     (add-to-list 'auto-mode-alist '("/bin/" . sh-mode))
   #+END_SRC

** Emacs Lisp

   Sure, everything here is in Emacs Lisp, but this section helps me
   write more of that... like making snazzy symbols and colourising the
   variables.

   The [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers]] project (unlike [[https://github.com/Fanael/rainbow-identifiers][others]]), downplay the
   keywords, and increase the colorising of the variables.

   #+BEGIN_SRC elisp
     (use-package color-identifiers-mode
       :ensure t
       :init
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
       :diminish color-identifiers-mode)
   #+END_SRC

   The only real snazzy symbol that I like is replacing the =lambda=
   with λ:

   #+BEGIN_SRC elisp
     (use-package lisp-mode
       :bind (:map emacs-lisp-mode-map ("C-c C-z" . ielm))
       :init
       (defconst lisp--prettify-symbols-alist
         '(("lambda"  . ?λ)      ; Shrink this
           ("."       . ?•)))    ; Enlarge this
       :config
       (add-hook 'emacs-lisp-mode-hook 'global-prettify-symbols-mode)
       (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
       (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent))
   #+END_SRC

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

    #+BEGIN_SRC elisp
      (use-package paredit
        :ensure t
        :diminish (paredit-mode "{}")
        :init
          (add-hook 'emacs-lisp-mode-hook 'paredit-mode))
    #+END_SRC

*** Insert Comment of Eval

    While writing and documenting Emacs Lisp code, it would be helpful
    to insert the results of evaluation of an s-expression directly
    into the code as a comment:

    #+BEGIN_SRC elisp
      (use-package lisp-mode
        :config (defun eval-and-comment-output ()
                  "Add the output of the sexp as a comment after the sexp"
                  (interactive)
                  (save-excursion
                    (end-of-line)
                    (condition-case nil
                        (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
                               (current-buffer))
                      (error (message "Invalid expression")))))

        :bind ("C-x e" . eval-and-comment-output))
    #+END_SRC

** Clojure

   See [[file:emacs-clojure.org][emacs-clojure.el]] for details on working with [[http://clojure.org][Clojure]].

   #+BEGIN_SRC elisp
     (require 'init-clojure)
   #+END_SRC

** Java

   As soon as a I have a project that requires Java (and doesn’t allow
   me to work on either Clojure or Scala, I’ll update my old Java
   initialisation section.

   #+BEGIN_SRC elisp
     (defun my-c-mode-hook ()
       (setq c-basic-offset 4)
       (c-set-offset 'substatement-open 0)   ; Curly braces alignment
       (c-set-offset 'case-label 4))         ; Switch case statements alignment

     (add-hook 'c-mode-hook 'my-c-mode-hook)
     (add-hook 'java-mode-hook 'my-c-mode-hook)
   #+END_SRC

** JavaScript

   See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-javascript)
   #+END_SRC

** HTML, CSS and other Web Programming

   See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-web)
   #+END_SRC

** Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

* Tools
** Git

   I like [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]:

   #+BEGIN_SRC elisp
     (use-package git-gutter-fringe
        :ensure t
        :diminish git-gutter-mode
        :init (setq git-gutter-fr:side 'right-fringe)
        :config (global-git-gutter-mode t))
   #+END_SRC

   I want to have special mode for Git's =configuration= file:

   #+BEGIN_SRC elisp
     (use-package gitconfig-mode
       :ensure t)

     (use-package gitignore-mode
       :ensure t)
   #+END_SRC

   What about being able to see the [[https://github.com/voins/mo-git-blame][Git blame]] in a buffer?

   #+BEGIN_SRC elisp
     (use-package mo-git-blame
        :ensure t)
   #+END_SRC

   Run =mo-git-blame-current= to see the goodies.

** Magit

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   Don't believe me? Check out [[https://www.youtube.com/watch?v=vQO7F2Q9DwA][this video]].

   #+BEGIN_SRC elisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :init
       (defadvice magit-status (around magit-fullscreen activate)
         (window-configuration-to-register :magit-fullscreen)
         ad-do-it
         (delete-other-windows))
       :config
       (setq magit-branch-arguments nil
             ;; use ido to look for branches
             magit-completing-read-function 'magit-ido-completing-read
             ;; don't put "origin-" in front of new branch names by default
             magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
             magit-push-always-verify nil
             ;; Get rid of the previous advice to go into fullscreen
             magit-restore-window-configuration t)

       :bind ("C-x g" . magit-status))
   #+END_SRC

   I like having Magit to run in a /full screen/ mode, and add the
   above =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]].

   *Note:* Use the [[https://github.com/jwiegley/emacs-release/blob/master/lisp/vc/smerge-mode.el][smerge-mode]] that is now part of Emacs.

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

   #+BEGIN_SRC elisp
     (use-package markdown-mode
       :ensure t
       :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
       :config
       (bind-key "A-b" (surround-text-with "+*") markdown-mode-map)
       (bind-key "s-b" (surround-text-with "**") markdown-mode-map)
       (bind-key "A-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "s-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "A-=" (surround-text-with "`") markdown-mode-map)
       (bind-key "s-=" (surround-text-with "`") markdown-mode-map))
   #+END_SRC

** PlantUML and Graphviz

   Install the [[http://www.graphviz.org/][Graphviz]] and [[http://plantuml.sourceforge.net/download.html][PlantUML]] projects using Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install graphviz
     brew link graphviz
     brew install plantuml
   #+END_SRC

   Load the [[https://github.com/wildsoul/plantuml-mode][mode for PlantUML]] and reference its jar:

   #+BEGIN_SRC elisp
     (let ((plantuml-jar (car (file-expand-wildcards "/usr/local/Cellar/plantuml/*/plantuml*.jar"))))
       (ignore-errors
         (use-package plantuml-mode
           :if plantuml-jar
           :init
           (setq plantuml-jar-path plantuml-jar
                 org-plantuml-jar-path plantuml-jar))))
   #+END_SRC

   And the [[http://ppareit.github.com/graphviz-dot-mode/][mode for Graphviz]]:

   #+BEGIN_SRC elisp
     (use-package graphviz-dot-mode
        :ensure t)
   #+END_SRC

* Applications
** EShell

   See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-eshell)
   #+END_SRC

** Chatting

   Using the [[http://www.emacswiki.org/emacs/JabberEl][jabber.el]] project to connect up to Google Talk and what
   not. To begin, make sure you =brew install gnutls=

   #+BEGIN_SRC elisp
     (use-package jabber
       :ensure t
       :commands jabber-connect-all jabber-chat-with
       :init
       (define-key personal-global-map (kbd "a") 'jabber-connect-all)
       (define-key personal-global-map (kbd "j") 'jabber-chat-with)
       :config
       (setq starttls-use-gnutls t
             starttls-gnutls-program "gnutls-cli"
             starttls-extra-arguments '("--starttls" "--insecure")

             jabber-history-enabled t
             jabber-use-global-history nil
             jabber-backlog-number 40
             jabber-backlog-days 30)

       (defun my-jabber-chat-delete-or-bury ()
         (interactive)
         (if (eq 'jabber-chat-mode major-mode)
             (condition-case e
                 (delete-frame)
               (error
                (if (string= "Attempt to delete the sole visible or iconified frame"
                             (cadr e))
                    (bury-buffer))))))

       (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury))
#+END_SRC

* Frivolous

  Life must be more whimsical. To begin, install the =fortune= package:
  #+BEGIN_SRC sh :tangle no
    brew install fortune   # Installs in /usr/local/share/games/fortunes
  #+END_SRC
  Or, if on Ubuntu:
  #+BEGIN_SRC sh :tangle no
    sudo apt-get install fortune # Installs in /usr/share/games/fortunes
  #+END_SRC

  Let's create a variable for knowing if we have everything installed:
  #+BEGIN_SRC elisp
    (defvar ha/can-haz-cookie-p t "Is true if the fortune system has been correctly configured")
  #+END_SRC

  Since fortune installs quite a few files (some of which we don't
  like), and we may want to run the same code on multiple operating
  systems, we write a little wrapper function around the =cookie=
  function to pick one of our favorite files (if available) at random:

  #+BEGIN_SRC elisp
    (defun ha/cookie ()
      "Returns a phrase from a random `fortune' file from standard locations."
      (interactive)
      (condition-case nil
          (let* ((favs "computers$\\|definitions$\\|drugs$\\|fortunes$\\|goedel$\\|linuxcookie$\\|magic$")
                 (paths '("/usr/share/games/fortunes" "/usr/local/share/games/fortunes"))
                 (path (car (-filter 'file-exists-p paths)))
                 (files (directory-files path t favs))
                 (file (nth (random (length files)) files)))
            (setq ha/can-haz-cookie-p t)
            (message "%s" (cookie file)))
        (error (message "Happy Hacking!"))))
  #+END_SRC

  And let's display a frivolous message each time we return to Emacs:

  #+BEGIN_SRC elisp
    (when ha/can-haz-cookie-p
      (add-hook 'focus-in-hook 'ha/cookie))
  #+END_SRC

* Windowed Env

** Setting up the Exec Path

   Make sure that =PATH= variable for finding binary files can is the
   same as what Emacs will look for binary files. This little magic,
   starts up a shell, gets its path, and then uses that for the
   =exec-path=:

   #+BEGIN_SRC elisp
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
         (setenv "PATH" path-from-shell)
         (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

   Before we finish, we need to check if there is a local file for us
   to load and evaluate.  We assume the local file has been tangled
   and provides the =init-local= key:

   #+BEGIN_SRC elisp
     (require 'init-local nil t)
   #+END_SRC

* Technical Artifacts
  Let's get happy:

   #+BEGIN_SRC elisp
     (defun display-startup-echo-area-message ()
       (message "¡ Feliz hacking pelotudo !"))
   #+END_SRC

   After the first load, we can reload this with a require:

   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Before you can build this on a new system, make sure that you put
   the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
