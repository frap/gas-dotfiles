#+TITLE:  Emacs Configuration File
#+AUTHOR: Andrés Gasson
#+EMAIL:  agasson@red-elvis.net

* Introduction

  This is my =.emacs= file ... well, the top-level of it anyway.
  I've written it in a [[http://www.orgmode.org][literate style]], to make it easy to explain.
  The notes also include hyperlinks to where I stole it. ;-)

** Emacs Executable

   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building Emacs
   from source using [[http://brew.sh/][Homebrew]]. I start by adding the following dependency:

   #+BEGIN_SRC sh :tangle no
     brew cask install xquartz
   #+END_SRC

   *Note:* I've been running into an issue where I want Emacs to display
   ligatures as well as work with the visual regular expression
   package.  To get the both to work, I find I need to build from
   source after applying [[https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6][this patch]]. According to the Homebrew
   documentation (see [[https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md#patches][the Patches section]]), we first:

   #+BEGIN_SRC sh :tangle no
     brew edit emacs
   #+END_SRC

   And add the following section

   #+BEGIN_EXAMPLE
   patch do
     url "https://github.com/minimal/emacs/commit/812dd5119645a09bc025a9dddedad9474d12ecb6.diff"
   end
   #+END_EXAMPLE

   And then build from source especially for the Mac:

   #+BEGIN_SRC sh :tangle no
     brew install emacs --HEAD --use-git-head --with-cocoa --with-gnutls --srgb --with-librsvg --with-ns --with-imagemagick

     brew linkapps emacs
   #+END_SRC

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=.

   All Homebrew options for Emacs can be seen with the command:

   #+BEGIN_SRC sh :tangle no
     brew options emacs
   #+END_SRC

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

   #+BEGIN_SRC elisp :tangle no
     ;; Load our Literate Programming version of our Dot Emacs
     ;; file, from file: ~/Work/dot-files/emacs.org
     (unless (boundp 'aquamacs-version)
       (load-file "~/.emacs.d/elisp/init-main.el")
       (server-start))
   #+END_SRC

   I only load this from a "normal" Emacs distribution, which
   allows me to play around with [[http://aquamacs.org/][Aquamacs]] and [[http://eschulte.github.io/emacs-starter-kit/][Starter Kits]].
   You know, to see what I may be missing.

* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, Aquamacs
   overrides that, and since I now feel the need to use these settings
   for both editors (sure feels like XEmacs all over again).

   Any way, I have a new global variable for that:

   #+BEGIN_SRC elisp
     (defconst ha/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun ha/emacs-subdirectory (d) (expand-file-name d ha/emacs-directory))
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   #+BEGIN_SRC elisp
     (let* ((subdirs '("elisp" "backups"))
            (fulldirs (mapcar (lambda (d) (ha/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "custom.el" ha/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

   #+BEGIN_SRC elisp
     (add-to-list 'load-path (ha/emacs-subdirectory "elisp"))
   #+END_SRC

   Load up my special collection of enhancements to Emacs Lisp:

   #+BEGIN_SRC elisp
     (require 'cl)
     (require 'init-support)
   #+END_SRC

* Package Initialisation
** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand.

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                              ("gnu"       . "http://elpa.gnu.org/packages/")
                              ("melpa"     . "http://stable.melpa.org/packages/")
                              ("marmalade" . "http://marmalade-repo.org/packages/")))

     (package-initialize)
     (package-refresh-contents)
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

** Init File Support

  Load up my collection of enhancements to Emacs Lisp, including dash and s for string manipulation, as much of my initialization code depends on it.

   #+BEGIN_SRC elisp
     (require 'cl)

     (use-package dash
       :ensure t
       :config (eval-after-load "dash" '(dash-enable-font-lock)))

     (use-package s
       :ensure t)
   #+END_SRC

* Variables

  General settings about me that other packages can use. The biggest
  problem is guessing my email address based on what computer I am using:

  #+BEGIN_SRC elisp
    (if (equal "gassona" user-login-name)
        (setq user-mail-address "andrew.gasson@anz.com")
      (setq user-mail-address "agasson@ateasystems.com"))
  #+END_SRC

** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** Encrypting Files

   Synchronise notes formatted in org-mode across multiple computers
   with cloud storage services, like Dropbox? Those files are /cached/
   in various other storage facilities... so, I use symmetric key
   encryption with [[http://en.wikipedia.org/wiki/Pretty_Good_Privacy][PGP]].

   To get started on the Mac, install the goodies:

   #+BEGIN_SRC sh :tangle no
     brew install gpg
   #+END_SRC

   Now, any file loaded with a =gpg= extension, e.g. =some.org.gpg=,
   will prompt for a password (and then use =org-mode=).  Since these
   files are for my eyes only, I don’t need the key-ring prompt:

   #+BEGIN_SRC elisp
     (setq epa-file-select-keys 2)
   #+END_SRC

   If you trust your Emacs session on your computer, you can have
   Emacs cache the password.

   #+BEGIN_SRC elisp
     (setq epa-file-cache-passphrase-for-symmetric-encryption t)
   #+END_SRC

* Display Settings

  I've been using Emacs for many years, and appreciate a certain
  minimalist approach to its display. While you can turn these off
  with the menu items now, it is just as easy to set them here.

  #+BEGIN_SRC elisp
    (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
    (setq visible-bell t)             ;; Get rid of the beeps

    (when (window-system)
      (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1))
      (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
  #+END_SRC

  Most of the display settings actually come from the [[file:emacs-mac.org][Mac initialization file]].

** Whitespace Mode

   You don't want this on all the time, but nice to turn it on every
   now and then:

   #+BEGIN_SRC elisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

** Fill Mode

   Automatically wrapping when you get to the end of a line (or the
   fill-region):

   #+BEGIN_SRC elisp
     (use-package fill
       :bind ("C-c T f" . auto-fill-mode)
       :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
       :diminish auto-fill-mode)
   #+END_SRC

* Key Bindings
** Displaying Command Sequences

   Many command sequences may be logical, but who can remember them
   all? While I used to use [[https://github.com/kai2nenobu/guide-key][guide-key]] to display the final function
   name, it isn't as nice as [[https://github.com/justbur/emacs-which-key][which-key]].

   #+BEGIN_SRC elisp
     (use-package which-key
       :ensure t
       :defer 10
       :diminish which-key-mode
       :config

       ;; Replacements for how KEY is replaced when which-key displays
       ;;   KEY → FUNCTION
       ;; Eg: After "C-c", display "right → winner-redo" as "▶ → winner-redo"
       (setq which-key-key-replacement-alist
             '(("<\\([[:alnum:]-]+\\)>" . "\\1")
               ("left"                  . "◀")
               ("right"                 . "▶")
               ("up"                    . "▲")
               ("down"                  . "▼")
               ("delete"                . "DEL") ; delete key
               ("\\`DEL\\'"             . "BS") ; backspace key
               ("next"                  . "PgDn")
               ("prior"                 . "PgUp"))

             ;; List of "special" keys for which a KEY is displayed as just
             ;; K but with "inverted video" face... not sure I like this.
             which-key-special-keys '("RET" "DEL" ; delete key
                                      "ESC" "BS" ; backspace key
                                      "SPC" "TAB")

             ;; Replacements for how part or whole of FUNCTION is replaced:
             which-key-description-replacement-alist
             '(("Prefix Command" . "prefix")
               ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
               ("\\`projectile-" . "𝓟/")
               ("\\`org-babel-"  . "ob/"))

             ;; Underlines commands to emphasize some functions:
             which-key-highlighted-command-list
             '("\\(rectangle-\\)\\|\\(-rectangle\\)"
               "\\`org-"))

       ;; Change what string to display for a given *complete* key binding
       ;; Eg: After "C-x", display "8 → +unicode" instead of "8 → +prefix"
       (which-key-add-key-based-replacements
         "C-x 8"   "unicode"
         "C-c T"   "toggles-"
         "C-c p s" "projectile-search"
         "C-c p 4" "projectile-other-buffer-"
         "C-x a"   "abbrev/expand"
         "C-x r"   "rect/reg"
         "C-c /"   "engine-mode-map"
         "C-c C-v" "org-babel")

       (which-key-mode 1))
   #+END_SRC

** Function Key Definitions

   Emacs has never seen a need for function keys, and I agree...for
   the most part. For things really /away from the flow/, they don't
   seem to bad. But what are those?

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Special odd, little-used characters that I have to think
            about before remembering what its binding.
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Move/Drop/Delete a visual 'mark'
   - *F6* - Open to temporary, changeable commands...
   - *F7* - Switch to another window ... Control goes the other way.
   - *F8* - Switch to buffer
   - *F9* - My extension (replacement?) for =C-c= for changing colors
     and other odd bindings that I actually don't use that often.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<f7>") 'other-window)
     (global-set-key (kbd "C-<f7>") (lambda () (interactive) (other-window -1)))
   #+END_SRC

*** F2 and F9 Helpers

    The F9 prefix is scattered about my config files.

    #+BEGIN_SRC elisp
      (define-prefix-command 'personal-global-map)
      (global-set-key (kbd "<f9>") 'personal-global-map)
    #+END_SRC

    Unlike the *F9* bindings, all the *F2* key-bindings happen in a
    single [[file:emacs-f2.org][library file]]:

    #+BEGIN_SRC elisp
      (require 'init-f2)
    #+END_SRC

** Highlighting and Narrowing

   I like the ability to highlight random text.

   - =M-s h .= :: highlight-symbol-at-point
   - =M-s h l= :: highlight-lines-matching-regexp
   - =M-s h p= :: highlight-phrase
   - =M-s h r= :: highlight-regexp
   - =M-s h u= :: unhighlight-regexp

   May get specific highlights automatically for certain files. We
   begin by highlighting lines in *.log files.

   #+BEGIN_SRC elisp
     (defun ha/highlite-logs ()
       "Highlight certain lines in specific files.  Currently, only log files are supported."
       (interactive)
       (when (equal "log" (file-name-extension (buffer-file-name)))
             (hi-lock-mode 1)
             (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
             (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))
   #+END_SRC

   The condition in this function that checks for the =log= extension,
   allows me to hook it to the loading of any file:

   #+BEGIN_SRC elisp :tangle no
     (add-hook 'find-file-hook 'ha/highlite-logs)
   #+END_SRC

   Turn on specific word groupings for specific occasions. We begin
   with highlighting keywords I use during note-taking sessions at
   the end of a sprint.

   #+BEGIN_SRC elisp
     (defun ha/sprint-retrospective-highlighting ()
       "Highlight the good, the bad and the improvements to make when taking notes."
       (interactive)
       (hi-lock-mode t)
       (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
       (highlight-phrase "TODO:?" 'hi-black-b)
       (highlight-regexp "(?Good)?:?" 'hi-green-b)
       (highlight-regexp "(?Bad)?:?" 'hi-red-b)
       (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))
   #+END_SRC

   This works really well with other commands, including
   [[https://github.com/Bruce-Connor/fancy-narrow][fancy-narrow]], where I can visually high-light a section of a
   buffer. Great for code-reviews and other presentations.

   #+BEGIN_SRC elisp
     (use-package fancy-narrow
       :ensure t
       :config
       (defun ha/highlight-block ()
         "Highlights a 'block' in a buffer defined by the first blank
          line before and after the current cursor position. Uses the
          'fancy-narrow' mode to high-light the block."
         (interactive)
         (let (cur beg end)
           (setq cur (point))
           (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
           (goto-char cur)
           (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
           (fancy-narrow-to-region beg end)
           (goto-char cur)))

       (defun ha/highlight-section (num)
         "If some of the buffer is highlighted with the `fancy-narrow'
          mode, then un-highlight it by calling `fancy-widen'.

          If region is active, call `fancy-narrow-to-region'.

          If NUM is 0, highlight the current block (delimited by blank
          lines). If NUM is positive or negative, highlight that number
          of lines.  Otherwise, called `fancy-narrow-to-defun', to
          highlight current function."
         (interactive "p")
         (cond
          ((fancy-narrow-active-p)  (fancy-widen))
          ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
          ((= num 0)                (ha/highlight-block))
          ((= num 1)                (fancy-narrow-to-defun))
          (t                        (progn (ha/expand-region num)
                                           (fancy-narrow-to-region (region-beginning) (region-end))))))

       :bind ("C-M-+" . ha/highlight-section))
   #+END_SRC

   This nifty function from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parenthesis]] is a nice replacement
   for many other narrowing keybindings that I use:

   #+BEGIN_SRC elisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens.  Otherwise, it narrows intelligently.
     Intelligently means: region, subtree, or defun, whichever applies
     first.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
             (t (narrow-to-defun))))

     (global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)
   #+END_SRC

** Jumping to Windows

  Set up [[https://github.com/abo-abo/ace-window][ace-window]] mode:

  #+BEGIN_SRC elisp
    (use-package ace-window
      :ensure t
      :init
        (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
        (global-set-key (kbd "C-x o") 'ace-window)
      :diminish ace-window-mode)
  #+END_SRC

** Selecting a Buffer

   I like =IDO= for switching buffers since I typically know what I'm after:

   #+BEGIN_SRC elisp
    (global-set-key (kbd "<f8>") 'ido-switch-buffer)
    (global-set-key (kbd "S-<f8>") 'ibuffer)
   #+END_SRC

   I like [[https://github.com/KMahoney/kpm-list][kpm-list]] a bit better than =ibuffer=, but I really don’t use
   either more than =ido-switch-buffer=. Still:

   #+BEGIN_SRC elisp
    (use-package kpm-list
      :ensure t
      :bind ("S-<f8>" . kpm-list)
            ("C-x C-b" . kpm-list))
   #+END_SRC

** Controlling Window Size

   Often, while on my laptop, I want the current window to be ‘large
   enough for work’, and this is bound to =<f9> .= (period).

   #+BEGIN_SRC elisp
     (global-unset-key (kbd "C-c w"))
     (global-set-key (kbd "C-c w r") 'ha/window-standard-size)
   #+END_SRC

   If I've enlarged the window, I can restore that window to its
   original size, so this requires a /buffer local variable/:

   #+BEGIN_SRC elisp
     (make-variable-buffer-local 'window-width-original)
   #+END_SRC

   Now a function that either changes the width to 80, or back to the
   original size if already at 80.

   #+BEGIN_SRC elisp
     (defun ha/window-standard-size (arg)
       "Set size of the current window to 80 characters.
     If already is 80 characters, reset to its previous size.  A
     prefix ARG can be given to set the window to a particular width."
       (interactive "p")

       ;; If not already set, let's store the current window width in our
       ;; buffer-local variable.
       (if (not (local-variable-p 'window-width-original))
           (setq window-width-original (window-width)))

       ;; The 'goal' is 80 unless we get a better argument, C-u 60 ...
       (let* ((goal-width (if (> arg 8) arg 80))
              (new-width (- goal-width (window-width))))

         (if (= new-width 0)    ; Already enlarged? Restore:
             (enlarge-window-horizontally (- window-width-original goal-width))
           (enlarge-window-horizontally new-width))))
   #+END_SRC

** Controlling Window Placement

   Change window configuration and then return to the old
   configuration with [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]].  Use =Control-C Arrow= keys to
   cycle through window/frame configurations.

   #+BEGIN_SRC elisp
     (use-package winner
       :ensure t
       :init (winner-mode 1))
   #+END_SRC

   While [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]] is easy to keep the current window configuration
   /clean/, the [[https://github.com/tlh/workgroups.el][workgroups]] project has more features. However, due to
   existing bugs in that project, I've switched to [[https://github.com/pashinin/workgroups2][workgroups2]]:

   Short answer for using it:

   - ~C-c a c~ to create and name a new /view/
   - Configure the screen as you like it
   - ~C-c a u~ to have that view as the base for that name
   - ~C-c a v~ to switch to a particular workgroup view.
   - ~C-c a C-s~ to save all workgroup views to the file.

** Better Jumping

   Mostly using the [[https://github.com/abo-abo/avy][avy]] project's [[help:avy-goto-word-1][avy-goto-word-1]] function, so I bind
   that to =C-c j=, but the recent update to include a timer feature,
   seems awful sweet:

   #+Begin_SRC elisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1 avy-goto-char-1 avy-goto-line avy-goto-char-timer
       :bind
       ("C-c j"   . avy-goto-word-1)
       ("A-j"     . avy-goto-word-1)    ; The Mac Command key
       ("s-j"     . avy-goto-word-1)    ; The Command key on Linux
       ("A-h"     . avy-goto-char-2)
       ("s-h"     . avy-goto-char-2)
       ("C-c k k" . avy-goto-char-timer)
       ("A-J"     . avy-goto-char-timer)    ; The Mac Command key
       ("s-J"     . avy-goto-char-timer)    ; The Command key on Linux
       ("C-c k j" . avy-goto-word-1)
       ("C-c k c" . avy-goto-char-1)
       ("C-c k l" . avy-goto-line)
       ("C-c k p" . avy-pop-mark)
       ("A-,"     . avy-pop-mark))
   #+END_SRC

   Other options (that require more of my memory), are bound
   to =C-c k=.

** Unfill Paragraph

   Unfilling a paragraph joins all the lines in a paragraph into a
   single line. Taken from [[http://www.emacswiki.org/UnfillParagraph][here]].

   #+BEGIN_SRC elisp
     (defun unfill-paragraph ()
       "Convert a multi-line paragraph into a single line of text."
       (interactive)
       (let ((fill-column (point-max)))
         (fill-paragraph nil)))

     ;; Handy key definition
     (define-key global-map "\M-Q" 'unfill-paragraph)
   #+END_SRC

** General Behaviour Fixes

   The subtle changes I've been making to Emacs behaviour has grown
   until I felt I should move it into [[file:emacs-fixes.org][its own source file]].

   #+BEGIN_SRC elisp
     (require 'init-fixes)
   #+END_SRC

** Expand Region

   Wherever you are in a file, and whatever the type of file, you can
   slowly increase a region selection by logical segments by using
   Magnar's [[https://github.com/magnars/expand-region.el][expand-region]] project.

   However, the normal experience for =expand-region= is interactive,
   expected to be called repeatedly to expand and contract the regions
   based on syntax, and whatnot. Since I am seldom sure what I will
   select if I give this function a numeric prefix, I created a
   wrapper function that will (when given a number), just select the
   number of lines for the region. Select the current line with a 0
   argument. No argument (well, =lines= is given 1 with no argument),
   then it just calls =expand-region=:

   #+BEGIN_SRC elisp
     (use-package expand-region
       :ensure t
       :config
       (defun ha/expand-region (lines)
         "Prefix-oriented wrapper around Magnar's `er/expand-region'.

     Call with LINES equal to 1 (given no prefix), it expands the
     region as normal.  When LINES given a positive number, selects
     the current line and number of lines specified.  When LINES is a
     negative number, selects the current line and the previous lines
     specified.  Select the current line if the LINES prefix is zero."
         (interactive "p")
         (cond ((= lines 1)   (er/expand-region 1))
               ((< lines 0)   (ha/expand-previous-line-as-region lines))
               (t             (ha/expand-next-line-as-region (1+ lines)))))

       (defun ha/expand-next-line-as-region (lines)
         (message "lines = %d" lines)
         (beginning-of-line)
         (set-mark (point))
         (end-of-line lines))

       (defun ha/expand-previous-line-as-region (lines)
         (end-of-line)
         (set-mark (point))
         (beginning-of-line (1+ lines)))

       :bind ("C-=" . ha/expand-region))
   #+END_SRC

** Block Wrappers

   While the =M-(= binding to =insert-pair= is great, I often need to
   wrap with other characters:

   #+BEGIN_SRC elisp
     (global-set-key (kbd "M-[") 'insert-pair)
     (global-set-key (kbd "M-{") 'insert-pair)
     (global-set-key (kbd "M-<") 'insert-pair)
     (global-set-key (kbd "M-'") 'insert-pair)
     (global-set-key (kbd "M-`") 'insert-pair)
     (global-set-key (kbd "M-\"") 'insert-pair)
   #+END_SRC

   But [[https://github.com/rejeep/wrap-region.el][wrap-region]] is even more flexible. In most editors, selecting
   text and typing anything replaces the selected text (see the
   [[info:emacs#Using%20Region][delete-selection-mode]]), but in this case, we can do something
   different... like wrapping:

   #+BEGIN_SRC elisp
     (use-package wrap-region
       :ensure   t
       :config
       (wrap-region-global-mode t)
       (wrap-region-add-wrappers
        '(("(" ")")
          ("[" "]")
          ("{" "}")
          ("<" ">")
          ("'" "'")
          ("\"" "\"")
          ("‘" "’"   "q")
          ("“" "”"   "Q")
          ("*" "*"   "b"   org-mode)                 ; bolden
          ("*" "*"   "*"   org-mode)                 ; bolden
          ("/" "/"   "i"   org-mode)                 ; italics
          ("/" "/"   "/"   org-mode)                 ; italics
          ("~" "~"   "c"   org-mode)                 ; code
          ("~" "~"   "~"   org-mode)                 ; code
          ("=" "="   "v"   org-mode)                 ; verbatim
          ("=" "="   "="   org-mode)                 ; verbatim
          ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
          ("**" "**" "b"   markdown-mode)            ; bolden
          ("*" "*"   "i"   markdown-mode)            ; italics
          ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
          ("`" "'"   "c"   lisp-mode)                ; code
          ))
       :diminish wrap-region-mode)
   #+END_SRC

   But in order to wrap text in a more general way (with just about
   any textual string), we need something more. Especially with the
   =expand-region= command, wrapping a logical block of text with a
   beginning and ending string really makes sense.

   #+BEGIN_SRC elisp
     (defun surround (start end txt)
       "Wrap region with textual markers.

      Without active region (START and END), use the current 'symbol /
     word' at point instead of TXT.

     Useful for wrapping parens and angle-brackets to also
     insert the matching closing symbol.

     This function also supports some `org-mode' wrappers:

       - `#s` wraps the region in a source code block
       - `#e` wraps it in an example block
       - `#q` wraps it in an quote block"
       (interactive "r\nsEnter text to surround: " start end txt)

       ;; If the region is not active, we use the 'thing-at-point' function
       ;; to get a "symbol" (often a variable or a single word in text),
       ;; and use that as our region.

       (if (not (region-active-p))
           (let ((new-region (bounds-of-thing-at-point 'symbol)))
             (setq start (car new-region))
             (setq end (cdr new-region))))

       ;; We create a table of "odd balls" where the front and the end are
       ;; not the same string.
       (let* ((s-table '(("#e" . ("#+BEGIN_EXAMPLE\n" "\n#+END_EXAMPLE") )
                         ("#s" . ("#+BEGIN_SRC \n"    "\n#+END_SRC") )
                         ("#q" . ("#+BEGIN_QUOTE\n"   "\n#+END_QUOTE"))
                         ("<"  . ("<" ">"))
                         ("("  . ("(" ")"))
                         ("{"  . ("{" "}"))
                         ("["  . ("[" "]"))))    ; Why yes, we'll add more
              (s-pair (assoc-default txt s-table)))

         ;; If txt doesn't match a table entry, then the pair will just be
         ;; the text for both the front and the back...
         (unless s-pair
           (setq s-pair (list txt txt)))

         (save-excursion
           (narrow-to-region start end)
           (goto-char (point-min))
           (insert (car s-pair))
           (goto-char (point-max))
           (insert (cadr s-pair))
           (widen))))

     (global-set-key (kbd "C-+") 'surround)
   #+END_SRC

   This function returns an interactive lambda expression, suitable
   for adding to a key-binding:

   #+BEGIN_SRC elisp
     (defun surround-text-with (surr-str)
       "Return an interactive function that when called, surrounds region (or word) with string, SURR-STR."
       (lexical-let ((text surr-str))
           (lambda ()
             (interactive)
             (if (region-active-p)
                 (surround (region-beginning) (region-end) text)
               (surround nil nil text)))))
   #+END_SRC

* Loading and Finding Files
** Dired Options

   Between =M-!= and starting [[Eshell][Eshell]], comes =dired= (=C-x d=).

   #+BEGIN_SRC elisp
     (setq ls-lisp-use-insert-directory-program nil)
   #+END_SRC

   This enhancement to dired hides the ugly details until you hit
   '(' and shows the details with ')'. I also change the [...] to a
   simple asterisk.

   #+BEGIN_SRC elisp
     (use-package dired-details
       :ensure t
       :init   (setq dired-details-hidden-string "* ")
       :config (dired-details-install))
   #+END_SRC

   The ability to create a dired buffer based on searching for files
   in a directory tree with =find-name-dired= is fantastic. The
   [[http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/][following magic]] optimizes this approach:

   #+BEGIN_SRC elisp
     (use-package find-dired
        :ensure t
        :init (setq find-ls-option '("-print0 | xargs -0 ls -od" . "-od")))
   #+END_SRC

   The [[http://pragmaticemacs.com/emacs/quickly-preview-images-and-other-files-with-peep-dired/][peep project]] allows you to preview files before loading them
   into a dedicated buffer:

   #+BEGIN_SRC elisp
     (use-package peep-dired
       :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
       :bind (:map dired-mode-map
                   ("P" . peep-dired)))
   #+END_SRC

   The [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][dired-x project]] seems useful:

   #+BEGIN_SRC elisp
     (use-package dired-x)
   #+END_SRC

** IDO (Interactively DO Things)

   According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

   #+BEGIN_SRC elisp
     (use-package ido
       :ensure t
       :init  (setq ido-enable-flex-matching t
                    ido-ignore-extensions t
                    ido-use-virtual-buffers t
                    ido-everywhere t)
       :config
       (ido-mode 1)
       (ido-everywhere 1)
       (add-to-list 'completion-ignored-extensions ".pyc"))
   #+END_SRC

   Add to IDO, the [[https://github.com/lewang/flx][FLX]] package:

   #+BEGIN_SRC elisp
     (use-package flx-ido
        :ensure t
        :init (setq ido-enable-flex-matching t
                    ido-use-faces nil)
        :config (flx-ido-mode 1))
   #+END_SRC

   According to [[https://gist.github.com/rkneufeld/5126926][Ryan Neufeld]], we could make IDO work vertically,
   which is much easier to read. For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

   #+BEGIN_SRC elisp
     (use-package ido-vertical-mode
       :ensure t
       :init               ; I like up and down arrow keys:
       (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
       :config
       (ido-vertical-mode 1))
   #+END_SRC

*** IDO File Listing by Modified Time

    This sorts an IDO filelist by /mtime/ instead of alphabetically.

    #+BEGIN_SRC elisp
      (defun ido-sort-mtime ()
        "Reorder the IDO file list to sort from most recently modified."
        (setq ido-temp-list
              (sort ido-temp-list
                    (lambda (a b)
                      (time-less-p
                       (sixth (file-attributes (concat ido-current-directory b)))
                       (sixth (file-attributes (concat ido-current-directory a)))))))
        (ido-to-end  ;; move . files to end (again)
         (delq nil (mapcar
                    (lambda (x) (and (char-equal (string-to-char x) ?.) x))
                    ido-temp-list))))

      (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
      (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
    #+END_SRC

*** Editing Root Files

    Once I wrote a =find-file-as-root= function (graciously borrowed from
    [[http://emacs-fu.blogspot.com/2013/03/editing-with-root-privileges-once-more.html][Emacs Fu]]), however, [[http://emacsredux.com/blog/2013/04/21/edit-files-as-root/][bbatsov]] gave me a better idea to lend some
    /advice/ to =find-file=, so that non-writable files would be
    automatically /re-opened/ using the =sudo= feature of Tramp.

    My version works with both local and remotely access files:

    #+BEGIN_SRC elisp
      (defadvice ido-find-file (after find-file-sudo activate)
        "Find file as root if necessary."
        (unless (and buffer-file-name
                     (file-writable-p buffer-file-name))
          (let* ((file-name (buffer-file-name))
                 (file-root (if (string-match "/ssh:\\([^:]+\\):\\(.*\\)" file-name)
                                (concat "/ssh:"  (match-string 1 file-name)
                                        "|sudo:" (match-string 1 file-name)
                                        ":"      (match-string 2 file-name))
                              (concat "/sudo:localhost:" file-name))))
            (find-alternate-file file-root))))
    #+END_SRC

    No special key-bindings, just load up a file, and if I can't write
    it, it will automatically ask me for my credentials, and away I go.

** SMEX

   Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]] to do something similar but with =M-x= commands:

   #+BEGIN_SRC elisp
     (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind ("M-x" . smex)
             ("M-X" . smex-major-mode-commands))
   #+END_SRC

** Helm

   Obviously, Helm would be helpful if I can learn all the bindings,
   so:

   #+BEGIN_SRC elisp
     (use-package helm
       :ensure t
       :init
       (use-package helm-config))   ;; Binds C-x c to the helm bidness.
   #+END_SRC

   Re-read [[http://tuhdo.github.io/helm-intro.html][this essay on Helm]].

** Grep for my Notes

   I have a voluminous amount of org-mode text files I routinely need
   search and filter.

   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs, but need a later
   version of Gnu Grep. On Mac OS X, run these two commands:

   #+BEGIN_SRC sh
     brew tap homebrew/dupes
     brew install homebrew/dupes/grep
   #+END_SRC

*** Silver Searcher

    With [[https://twitter.com/_wilfredh][Wilfred Hughes]]' fancy [[https://github.com/Wilfred/ag.el/#agel][ag package]], I’ve switch from [[http://beyondgrep.com][ack]] to the
    [[http://geoff.greer.fm/2011/12/27/the-silver-searcher-better-than-ack/][Silver Searcher]]:

    #+BEGIN_SRC sh
      b
rew install ag
    #+END_SRC

    Best part about the ag package, is not needing any configuration
    (as all functions are load-on demand).

    - =ag-project-at-point= :: sets the query with the word at point, use: =C-c p s s=
    - =ag-regexp= :: searches for regular expressions in a chosen
                     directory (*Note:* the =ag= command prompts with
                     =regexp=, but it adds a =--literal= option to the command)
    - =C-u= :: Adding a prefix adds command line options, like =-s= or
               =-i= to specify case-sensitivity.

    Create collection of [[file:~/.agignore][ignorable files]] so it doesn’t look in backup files:

    #+BEGIN_SRC org :tangle ~/.agignore
      #.*
    #+END_SRC

    Using the latest version of =ag=? Highlight the keywords:

    #+BEGIN_SRC elisp
      (use-package ag
        :ensure    t
        :commands  ag
        :init      (setq ag-highlight-search t)
        :config    (add-to-list 'ag-arguments "--word-regexp"))
    #+END_SRC

    Personally, I’m almost /always/ looking for full words:

*** Spotlight

    However, I also need a global /indexing/ approach to searching
    through my notes, and since I'm usually on a Mac, I might as well
    use the /Spotlight/ service that is already running:

    #+BEGIN_SRC elisp
      (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
      (global-set-key (kbd "C-c f l") 'locate)
    #+END_SRC

    The following function wraps =locate-with-filter= to only grab
    =org-mode= files:

    #+BEGIN_SRC elisp
      (defun locate-org-files (search-string)
        "Adjust `locate-with-filter' to only search `org-mode' files with SEARCH-STRING."
        (interactive "sSearch string: ")
        (locate-with-filter search-string ".org$"))

      (global-set-key (kbd "C-c f o") 'locate-org-files)
    #+END_SRC

    We /could/ limit the location that Spotlight request searches:

    #+BEGIN_SRC elisp :tangle no
      (defun locate-my-org-files (search-string)
        (let ((tech (concat (getenv "HOME") "/technical"))
              (pers (concat (getenv "HOME") "/personal"))
              (note (concat (getenv "HOME") "/notes"))
              (jrnl (concat (getenv "HOME") "/journal")))
          (-flatten (list "mdfind"
                   (if (file-exists-p tech) (list "-onlyin" tech))
                   (if (file-exists-p pers) (list "-onlyin" pers))
                   (if (file-exists-p note) (list "-onlyin" note))
                   (if (file-exists-p jrnl) (list "-onlyin" jrnl))
                   "-interpret" search-string))))

      (setq locate-make-command-line 'locate-my-org-files)
    #+END_SRC

    However, the problem with locate, is it doesn't show me any
    context. My [[file:bin/find-notes][find-notes]] script uses both =mdfind= and =grep= to both
    better search and display some useful context.

    Just need to wrap that in a function:

    #+BEGIN_SRC elisp
      (defun find-notes (words)
        "Search `org-mode' files in specific directories for WORDS.

      Uses `find-notes' shell script as a better grep utility.  Not only
      does it show the results in a clickable list, it also highlights
      the result, allowing us to put more context in the output."
        (interactive "sSearch for words:")
        (let ((program (concat (getenv "HOME") "/bin/find-notes"))
              (buffer-name (concat "*find-notes: " words "*")))
          (call-process program nil buffer-name t words)
          (switch-to-buffer buffer-name)
          (read-only-mode 1)
          (grep-mode)
          (toggle-truncate-lines)
          (beginning-of-buffer)
          (dolist (word (split-string words))
            (highlight-regexp word))))

      (global-set-key (kbd "C-x C-n") 'find-notes)
      (global-set-key (kbd "C-c f n") 'find-notes)
    #+END_SRC

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

   #+BEGIN_SRC elisp
     (use-package recentf
       :init
       (setq recentf-max-menu-items 25
             recentf-auto-cleanup 'never
             recentf-keep '(file-remote-p file-readable-p))
       (recentf-mode 1)
       (let ((last-ido "~/.emacs.d/ido.last"))
         (when (file-exists-p last-ido)
           (delete-file last-ido)))
       :bind ("C-c f f" . recentf-open-files))
   #+END_SRC

   We do not want to stat all the files when Emacs starts up because
   files read by Tramp will slow down the start time.

** Backup Settings

   This setting moves all backup files to a central location.
   Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

   #+BEGIN_SRC elisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (ha/emacs-subdirectory "backups")))))
   #+END_SRC

   Make backups of files, even when they're in version control

   #+BEGIN_SRC elisp
     (setq vc-make-backup-files t)
   #+END_SRC

   And let’s make sure our files are saved if we wander off and
   defocus the Emacs application:

   #+BEGIN_SRC elisp
     (defun save-all ()
       "Save all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC

* Word Smithing
** Auto Insertion

   Just beginning to get a collection of templates to automatically
   insert if a blank file is loaded.

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :init
       (setq auto-insert-directory (ha/emacs-subdirectory "templates/"))
       ;; Don't want to be prompted before insertion:
       (setq auto-insert-query nil)

       (add-hook 'find-file-hook 'auto-insert)
       (auto-insert-mode 1))
   #+END_SRC

   Add a =:config= section to configure static insertion, and add:

   #+BEGIN_SRC elisp :tangle no
     (define-auto-insert "\\.html?$" "default-html.html")
   #+END_SRC

   However, auto insertion requires entering data for particular fields,
   and for that Yasnippet is better, so in this case, we combine them:

   #+BEGIN_SRC elisp
     (defun ha/autoinsert-yas-expand()
       "Replace text in yasnippet template."
       (yas-expand-snippet (buffer-string) (point-min) (point-max)))
   #+END_SRC

   Now bind many of the templates for auto-insert and field expansion:

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :config
       (define-auto-insert "\\.el$" ["default-lisp.el" ha/autoinsert-yas-expand])
       (define-auto-insert "\\.sh$" ["default-sh.sh" ha/autoinsert-yas-expand])
       (define-auto-insert "/bin/"  ["default-sh.sh" ha/autoinsert-yas-expand])
       (define-auto-insert "\\.html?$" ["default-html.html" ha/autoinsert-yas-expand]))
   #+END_SRC

** Auto Complete

   Using [[http://company-mode.github.io/][company-mode]] for all my auto completion needs.

   Like [[https://github.com/vspinu/company-math][this idea]] of being able to easily insert math
   symbols based on LaTeX keywords. Start typing a backslash.

   #+BEGIN_SRC elisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       :diminish company-mode)
   #+END_SRC

   Take advantage of idle time by displaying some documentation
   using [[https://www.github.com/expez/company-quickhelp][company-quickhelp]] project.

   #+BEGIN_SRC elisp
     (use-package company-quickhelp
       :ensure t
       :config
       (company-quickhelp-mode 1))
   #+END_SRC

   This also requires [[https://github.com/pitkali/pos-tip/blob/master/pos-tip.el][pos-tip]].

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

   #+BEGIN_SRC elisp
     (use-package yasnippet
       :ensure t
       :init
       (yas-global-mode 1)
       :config
       (add-to-list 'yas-snippet-dirs (ha/emacs-subdirectory "snippets")))
   #+END_SRC

   *Note:*: the =snippets= directory contains directories for each
   mode, e.g.  =clojure-mode= and =org-mode=.

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses the built-in
   spell-check settings of [[https://www.gnu.org/software/ispell/][ispell]].

   The [[http://aspell.net][ASpell]] project is better supported than ISpell.

   #+BEGIN_SRC sh :tangle no
     brew install aspell
   #+END_SRC

   Start for all text modes (but not for log files):

   #+BEGIN_SRC elisp
     (use-package flyspell
       :ensure t
       :diminish flyspell-mode
       :init
       (add-hook 'prog-mode-hook 'flyspell-prog-mode)

       (dolist (hook '(text-mode-hook org-mode-hook))
         (add-hook hook (lambda () (flyspell-mode 1))))

       (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
         (add-hook hook (lambda () (flyspell-mode -1))))

       :config
       (setq ispell-program-name "/usr/local/bin/aspell"
             ispell-dictionary "british" ; better for aspell
             ispell-extra-args '("--sug-mode=ultra" "--lang=en_NZ")
             ispell-list-command "--list")

       (add-to-list 'ispell-local-dictionary-alist '(nil
                                                     "[[:alpha:]]"
                                                     "[^[:alpha:]]"
                                                     "['‘’]"
                                                     t
                                                     ("-d" "en_NZ")
                                                     nil
                                                     utf-8)))
   #+END_SRC

   ASpell automatically configures a personal dictionary
   at =~/.aspell.en.pws=, so no need to configure that.

   According to [[http://pragmaticemacs.com/emacs/jump-back-to-previous-typo/][this essay]], we can make a =flyspell-goto-previous-error=
   (which really should be added to the official =flyspell= project):

   #+BEGIN_SRC elisp
     (defun flyspell-goto-previous-error (arg)
       "Go to ARG previous spelling error."
       (interactive "p")
       (while (not (= 0 arg))
         (let ((pos (point))
               (min (point-min)))
           (when (and (eq (current-buffer) flyspell-old-buffer-error)
                      (eq pos flyspell-old-pos-error))
             (if (= flyspell-old-pos-error min)
                 ;; goto beginning of buffer
                 (progn
                   (message "Restarting from end of buffer")
                   (goto-char (point-max)))
               (backward-word 1))
             (setq pos (point)))

           ;; seek the next error
           (while (and (> pos min)
                       (let ((ovs (overlays-at pos))
                             (r '()))
                         (while (and (not r) (consp ovs))
                           (if (flyspell-overlay-p (car ovs))
                               (setq r t)
                             (setq ovs (cdr ovs))))
                         (not r)))
             (backward-word 1)
             (setq pos (point)))
           ;; save the current location for next invocation
           (setq arg (1- arg))
           (setq flyspell-old-pos-error pos)
           (setq flyspell-old-buffer-error (current-buffer))
           (goto-char pos)
           (if (= pos min)
               (progn
                 (message "No more miss-spelled words!")
                 (setq arg 0))))))
   #+END_SRC

** Spell Correction with Abbreviation Mode

   According to [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this discussion]], we can correct a misspelled word with
   ~Super-;~ (similar to ~C-;~), but it will use the abbreviation mode to
   automatically correct that word...as long as you misspell it the
   same way each time.

   #+BEGIN_SRC elisp
     (defun ha/ispell-word-then-abbrev (p)
       "Call `ispell-word'.  After create an abbrev for the correction made.
     With prefix P, create local abbrev.  Otherwise it will be
     global."
       (interactive "P")
       (flyspell-goto-previous-error 1)
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft)
           (abbrev-edit-save-to-file abbrev-file-name)
           (message "\"%s\" now expands to \"%s\" %s"
                    bef aft (if p "locally" "globally")))))
   #+END_SRC

   Need to turn on the mode, but not necessarily show it:

   #+BEGIN_SRC elisp
     (use-package abbrev
       :bind ("C-c T a" . abbrev-mode)
             ("A-;" . ha/ispell-word-then-abbrev)
       :init (setq save-abbrevs t)
             (setq-default abbrev-mode t)
       :diminish abbrev-mode)
   #+END_SRC

* Miscellaneous Settings

** Line Numbers

   Turn =linum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
   section above).  However, I turn this on automatically for
   programming modes.

   #+BEGIN_SRC elisp
     (use-package linum
       :init
       (add-hook 'prog-mode-hook 'linum-mode)
       (add-hook 'linum-mode-hook (lambda () (set-face-attribute 'linum nil :height 110)))

       :config
       (defun linum-fringe-toggle ()
         "Toggles the line numbers as well as the fringe."    (interactive)
         (cond (linum-mode (fringe-mode '(0 . 0))
                           (linum-mode -1))
               (t          (fringe-mode '(8 . 0))
                           (linum-mode 1))))

       :bind (("A-C-k"   . linum-mode)
              ("s-C-k"   . linum-mode)
              ("A-C-M-k" . linum-fringe-toggle)
              ("s-C-M-k" . linum-fringe-toggle)))
   #+END_SRC

   *Note:* make the line numbers a fixed size, then increasing or
   decreasing the font size doesn't truncate the numbers.

   The [[https://github.com/coldnew/linum-relative][linum-relative]] mode allows one to see the /destination/ line as a
   relative distance (like one 9 lines lower), and then =C-9 C-n= can
   quickly pop to it.

   #+BEGIN_SRC elisp
     (use-package linum-relative
       :ensure t
       :config
       (defun linum-new-mode ()
         "If line numbers aren't displayed, then display them.
          Otherwise, toggle between absolute and relative numbers."
         (interactive)
         (if linum-mode
             (linum-relative-toggle)
           (linum-mode 1)))

       :bind ("A-k" . linum-new-mode)
             ("s-k" . linum-new-mode))   ;; For Linux
   #+END_SRC

** Better Bookmarks

   For me, bookmarks serve two functions. First, as a way to jump
   back to interesting places by name (and annotate those places), and
   second, as form of /bread crumbs/ while I'm toiling around a large
   codebase.

   For normal bookmarks, I'd rather use Helm:
   #+BEGIN_SRC elisp
     (use-package bookmark
       :init (setq bookmark-save-flag 1)
       :config
       (defun ha/add-bookmark (name)
         (interactive
          (list (let* ((filename  (file-name-base (buffer-file-name)))
                       (project   (projectile-project-name))
                       (func-name (which-function))
                       (initial   (format "%s::%s:%s " project filename func-name)))
                  (read-string "Bookmark: " initial))))
         (bookmark-set name))
       :bind  (("C-c b m" . ha/add-bookmark)
               ("C-x r m" . ha/add-bookmark)
               ("C-x r b" . helm-bookmarks)))
   #+END_SRC

*** Visual Bookmarks... Breadcrumbs

    For dropping visual breadcrumbs throughout a single file or
    multiple files, we use the [[https://github.com/joodland/bm][BM package]].

    #+BEGIN_SRC elisp
      (use-package bm
        :ensure t
        :init
        (setq bm-highlight-style 'bm-highlight-only-fringe
              bm-cycle-all-buffers t)
        :config
        ;; Make a more bookmarky symbol for a 'mark':
       ;; (define-fringe-bitmap 'bm-marker-left [254 254 254 254 254 238 198 130] 8 8 'center)
        (let ((fringe-backgd (face-background 'fringe)))
          (set-face-attribute 'bm-fringe-face nil
                              :foreground "green" :background fringe-backgd))

        (defun bm-bookmark-defun ()
          "Drops a temporary breadcrumb/bookmark at the beginning of the current defun."
          (interactive)
          (save-excursion
            (beginning-of-defun)
            (bm-toggle)))

        :bind (("C-<f5>" . bm-toggle)
               ("<f5>"   . bm-next)
               ("M-<f5>" . bm-previous)
               ("C-c b s" . bm-show)
               ("C-c b r" . bm-bookmark-regexp)
               ("C-c b f" . bm-bookmark-defun)
               ("C-c b A" . bm-bookmark-annotate)
               ("C-c b a" . bm-bookmark-show-annotation)
               ("<left-margin> <mouse-1>" . bm-toggle-mouse)
               ("<left-fringe> <mouse-1>" . bm-toggle-mouse)))
    #+END_SRC

    - C-F5 :: bm-toggle to drop a mark or remove it
    - F5 :: bm-next to go to the next mark
    - M-F5 :: bm-previous to go to the previous mark

    - C-c b s :: bm-show brings up a buffer with all the little marks
         and the contents their line (see =bm-show-all= for all buffers)
    - C-c b r :: bm-bookmark-regexp to create a bunch of bookmarks
    - C-c b f :: bm-bookmark-function to bookmark the start of the function
    - C-c b A :: bm-bookmark-annotate Annotate the mark
    - C-c b a ::  Show the annotation (if any of the mark) ... would be
         nice if this could be automatically displayed.

    The biggest question is if I want =bm-previous= to go to the previous
    logical mark in the file or last mark that was set... perhaps we
    do both with different keys?

** Smart Comments

   The [[https://github.com/paldepind/smart-comment][smart-comment]] project has the nice feature of commenting a line
   without being at the beginning of the line (default comment in the
   middle of the line is to split it).

   #+BEGIN_SRC elisp
     (use-package smart-comment
       :bind ("M-;" . smart-comment))
   #+END_SRC

   Also has the ability (with the =C-u= prefix) to mark comments as
   things to be deleted.

** Smart Scan

   Use the =M-n= to search the buffer for the word the cursor is
   currently pointing. =M-p= to go backwards. See [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][this essay]] for
   details.

   #+BEGIN_SRC elisp :tangle no
     (use-package smartscan
       :ensure t
       :bind ("M-n" . smartscan-symbol-go-forward)
             ("M-p" . smartscan-symbol-go-backward))
   #+END_SRC

** Strip Whitespace on Save

   When I save, I want to always, and I do mean always strip all
   trailing whitespace from the file.

   #+BEGIN_SRC elisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

** Save File Position

   Save the point position for every file, and restore it when that
   file is reloaded.

   #+BEGIN_SRC elisp
     (use-package saveplace
        :init
        (setq-default save-place t)
        (setq save-place-forget-unreadable-files t
              save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)"))
   #+END_SRC

** Better Searching and Visual Regular Expressions

   Searching is quite good in Emacs. Let's add a few extra keys:

   #+BEGIN_SRC elisp
     (bind-keys :map isearch-mode-map
                ("<left>"  . isearch-repeat-backward)
                ("<right>" . isearch-repeat-forward)
                ("<up>"    . isearch-ring-retreat)
                ("<down>"  . isearch-ring-advance))
   #+END_SRC

   Easier replacement of my [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][Smart Scan]] for searching forward/backward
   for the current word. This is now bound to =M-s .= (in Emacs 24.4),
   but I then have to hit =C-s= or =C-r= ... nicer to use the period/comma.

   The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
   while you try to remember the differences between Perl's regular
   expressions and Emacs'...

   Begin with =C-c r= then type the regexp. To see the highlighted
   matches, type =C-c a= before you hit 'Return' to accept it.

   #+BEGIN_SRC elisp
     (use-package visual-regexp
       :ensure t
       :init
       (use-package visual-regexp-steroids :ensure t)

       :bind (("C-c r" . vr/replace)
              ("C-c q" . vr/query-replace))

       ;; if you use multiple-cursors, this is for you:
       :config (use-package  multiple-cursors
                 :bind ("C-c m" . vr/mc-mark)))
   #+END_SRC

** Flycheck

   [[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to good ol' Flymake.

   #+BEGIN_SRC elisp
     (use-package flycheck
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-flycheck-mode)
       :config
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
   #+END_SRC

** Hungry Delete

   The Hungry Delete project is a [[http://endlessparentheses.com//hungry-delete-mode.html][free feature]], where deleting any
   space, deletes ALL spaces.

   This is already built into Emacs with the following:
   - =M-\= :: Removes all spaces
   - =M-SPC= :: Removes extra spaces, leaving just one
   - =M-^= :: Joins current line with previous line (doesn't matter
        where the point is on the line)
   - =M-- M-1 M-SPC= :: Joins next line to this one (if point at end
        of line) separated by a space ... quite the chording, eh?

** Table and Column Alignment

   While I shouldn't, I like to line up comma-separated columns (and
   colon-delimited hashes), and since I can never type the regular
   expression on the first time, I wrapped it up in a callable
   function.

   #+BEGIN_SRC elisp
     (defun align-comma (start end c)
       "Repeat alignment with a character padded with spaces for
     comma-separated columns."
       (interactive "r\nsAlign character: ")
       (align-regexp start end
                     (concat c "\\(\\s-*\\)") 1 1 t))
   #+END_SRC

* Programming Languages

** General Language Support

   Many programming language environments can benefit from this section.

*** ElDoc

    I like ElDoc support (when I can get it), but not needed in the
    mode line:

    #+BEGIN_SRC elisp
      (use-package eldoc
        :diminish eldoc-mode)
    #+END_SRC

*** Tag Support

   All programming languages require some sort of tagging. but after
   thirty years, we are still using good ol’ ctags...well,
   [[http://ctags.sourceforge.net][Exuberant Ctags]].   Install with Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install --HEAD ctags
   #+END_SRC

   On Ubuntu Linux, do:

   #+BEGIN_SRC sh :tangle no
     sudo apt-get install -y exuberant-ctags
   #+END_SRC

   Note: for every project, run the following command:

   #+BEGIN_SRC sh :tangle no
     ctags -e -R .
   #+END_SRC

   I want to be able to add headers from my =org-mode= files as
   a /language option/:

   #+BEGIN_SRC sh :tangle ~/.ctags :comments no
    --langdef=org
    --langmap=org:.org
    --regex-org=/^\*+[ \t]+([a-zA-Z0-9_ ]+)/\1/d,definition/
   #+END_SRC

   We access stuff by loading the =etags= package:

   #+BEGIN_SRC elisp
     (use-package etags
        :init (setq tags-revert-without-query 1))
   #+END_SRC

   Now, use the following keys:

   - M-. :: To find the tag at point to jump to the function’s
            definition when the point is over a function call. It is a
            dwim-type function.
   - M-, :: jump back to where you were.
   - M-? :: find a tag, that is, use the Tags file to look up a
            definition. If there are multiple tags in the project with
            the same name, use `C-u M-.’ to go to the next match.
   - =M-x tags-search= :: regexp-search through the source files
        indexed by a tags file (a bit like =grep=)
   - =M-x tags-query-replace= :: query-replace through the source files
        indexed by a tags file
   - =M-x tags-apropos= :: list all tags in a tags file that match a
        regexp
   - =M-x list-tags= :: list all tags defined in a source file

   With the fancy new [[https://marmalade-repo.org/packages/ctags-update][ctags-update]] package, we can update the tags file
   whenever we save a file:

   #+BEGIN_SRC elisp
     (use-package ctags-update
       :ensure t
       :config
       (add-hook 'prog-mode-hook  'turn-on-ctags-auto-update-mode)
       :diminish ctags-auto-update-mode)
   #+END_SRC

   While, I like =imenu=, [[https://github.com/vspinu/imenu-anywhere][combining it]] with an IDO interface nicely
   lists the headings/functions in the current buffer:

   #+BEGIN_SRC elisp
     (use-package idomenu
       :ensure t
       :bind ("C-c i" . idomenu))
   #+END_SRC

   If I don't know what I'm after, Helm is better:

   #+BEGIN_SRC elisp
     (use-package helm
       :bind (("C-c M-i" . helm-imenu)))
   #+END_SRC

   However, I need to use [[http://www.emacswiki.org/emacs/EtagsSelect#toc3][this function]] to use IDO in conjunctions
   with the TAGS file for all functions in the project:

   #+BEGIN_SRC elisp
     (use-package ido
       :config
       (defun ido-find-tag ()
         "Find a tag using ido"
         (interactive)
         (tags-completion-table)
         (let (tag-names)
           (mapatoms (lambda (x)
                       (push (prin1-to-string x t) tag-names))
                     tags-completion-table)
           (find-tag (ido-completing-read "Tag: " tag-names))))

       (global-set-key (kbd "C-c I") 'ido-find-tag))
   #+END_SRC

   Emacs 25 changed has now deprecated the famous [[info:emacs#Tags][Tags and Friends]],
   like =find-tags= for =xref=. Some point, I will have to learn how
   to configure it, but until then, I'll just rebind to my old mates:

   #+BEGIN_SRC elisp :tangle no
     (global-set-key (kbd "M-.") 'find-tag)
     (global-set-key (kbd "C-M-.") 'find-tag-regexp)
     (global-set-key (kbd "M-,") 'pop-tag-mark)
     (global-set-key (kbd "M-i") 'imenu-anywhere)
   #+END_SRC

   Note: This prompt needs to go away:

   #+BEGIN_SRC elisp
     (setq tags-add-tables nil)
   #+END_SRC

*** Code Block Folding

    The [[info:emacs#Hideshow][Hide Show Minor]] mode allows us to /fold/ all functions
    (hidden), showing only the header lines. We need to turn on the
    mode, so wrappers are in order:

    #+BEGIN_SRC elisp
      (defun ha/hs-show-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-show-all))

      (defun ha/hs-hide-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-hide-all))

      (defun ha/hs-toggle-hiding ()
        (interactive)
        (hs-minor-mode 1)
        (hs-toggle-hiding))
    #+END_SRC

    Seems that =C-c @= is too obnoxious to use, so I'll put my
    favorite on the =C-c h= prefix:

    #+BEGIN_SRC elisp
      (use-package hs-minor-mode
        :bind
        ("C-c T h" . hs-minor-mode)
        ("C-c h a" . ha/hs-hide-all)
        ("C-c h s" . ha/hs-show-all)
        ("C-c h h" . ha/hs-toggle-hiding))
    #+END_SRC

    See the [[http://www.emacswiki.org/emacs/HideShow][online resources]].

*** Aggressive Auto Indention

    Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
    and seems to be quite helpful for many types of programming
    languages.

    To begin, we create a function that can indent a function by
    calling =indent-region= on the beginning and ending points of a
    function.

    #+BEGIN_SRC elisp
      (defun indent-defun ()
        "Indent current defun.
      Do nothing if mark is active (to avoid deactivaing it), or if
      buffer is not modified (to avoid creating accidental
      modifications)."
        (interactive)
        (unless (or (region-active-p)
                    buffer-read-only
                    (null (buffer-modified-p)))
          (let ((l (save-excursion (beginning-of-defun 1) (point)))
                (r (save-excursion (end-of-defun 1) (point))))
            (cl-letf (((symbol-function 'message) #'ignore))
              (indent-region l r)))))
    #+END_SRC

    Next, create a hook that will call the =indent-defun= with every
    command call:

    #+BEGIN_SRC elisp
      (defun activate-aggressive-indent ()
        "Locally add `ha/indent-defun' to `post-command-hook'."
        (add-hook 'post-command-hook
                  'indent-defun nil 'local))
    #+END_SRC

*** Red Warnings

    Various keywords (in comments) are now flagged in a Red Error font:

    #+BEGIN_SRC elisp
      (add-hook 'prog-common-hook
                (lambda ()
                  (font-lock-add-keywords nil
                                          '(("\\<\\(FIX\\|FIXME\\|TODO\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))))
    #+END_SRC

** Shell Scripts

   Files in my =bin= directory (but /only/ if it doesn't have any
   other extension), should start in =sh-mode=:

   #+BEGIN_SRC elisp
     (add-to-list 'auto-mode-alist '("/bin/" . sh-mode))
   #+END_SRC

** Emacs Lisp

   Sure, everything here is in Emacs Lisp, but this section helps me
   write more of that... like making snazzy symbols and colorising the
   variables.

   The [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers]] project (unlike [[https://github.com/Fanael/rainbow-identifiers][others]]), downplay the
   keywords, and increase the colorizing of the variables.

   #+BEGIN_SRC elisp
     (use-package color-identifiers-mode
       :ensure t
       :init
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
       :diminish color-identifiers-mode)
   #+END_SRC

   The only real snazzy symbol that I like is replacing the =lambda=
   with λ:

   #+BEGIN_SRC elisp
     (use-package lisp-mode
       :init
       (defconst lisp--prettify-symbols-alist
         '(("lambda"  . ?λ)
           ("."       . ?•)))
       :config
       (add-hook 'emacs-lisp-mode-hook 'global-prettify-symbols-mode)
       (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent))
   #+END_SRC

*** Dash List Library

    [[https://github.com/magnars/dash.el][Dash]] is cool and useful for dealing with collections in a standard
    functional way.

    #+BEGIN_SRC elisp
      (use-package dash
        :ensure t
        :defer 60
        :config (eval-after-load "dash" '(dash-enable-font-lock)))
    #+END_SRC

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

    #+BEGIN_SRC elisp
      (use-package paredit
        :ensure t
        :diminish paredit-mode
        :init
          (add-hook 'emacs-lisp-mode-hook 'paredit-mode))
    #+END_SRC

*** Coloured Variables

    Colour each variable, and downplay standard key words:

    #+BEGIN_SRC elisp
      (use-package color-identifiers-mode
        :ensure t
        :init
        (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode))
    #+END_SRC

*** Nicer Paren Matching

    The reverse mode of the default parenthesis matching doesn’t match
    as well, so [[http://www.emacswiki.org/emacs/ShowParenMode][this code]] just makes it bold and more obvious:

    #+BEGIN_SRC elisp
      (use-package paren
        :init
        (set-face-background 'show-paren-match (face-background 'default))
        (set-face-foreground 'show-paren-match "#afa")
        (set-face-attribute  'show-paren-match nil :weight 'black)
        (set-face-background 'show-paren-mismatch (face-background 'default))
        (set-face-foreground 'show-paren-mismatch "#c66")
        (set-face-attribute  'show-paren-mismatch nil :weight 'black))
    #+END_SRC

    While we are at it, let's dim the parens:

    #+BEGIN_SRC elisp
      (use-package paren-face
        :ensure t
        :init
        (global-paren-face-mode))
    #+END_SRC

*** Insert Comment of Eval

    While writing and documenting Emacs Lisp code, it would be helpful
    to insert the results of evaluation of an s-expression directly
    into the code as a comment:

    #+BEGIN_SRC elisp
      (use-package lisp-mode
        :config (defun eval-and-comment-output ()
                  "Add the output of the sexp as a comment after the sexp"
                  (interactive)
                  (save-excursion
                    (end-of-line)
                    (condition-case nil
                        (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
                               (current-buffer))
                      (error (message "Invalid expression")))))

        :bind ("C-x e" . eval-and-comment-output))
    #+END_SRC

** Clojure

   See [[file:emacs-clojure.org][emacs-clojure.el]] for details on working with [[http://clojure.org][Clojure]].

   #+BEGIN_SRC elisp
     (require 'init-clojure)
   #+END_SRC

** Java

   As soon as a I have a project that requires Java (and doesn’t allow
   me to work on either Clojure or Scala, I’ll update my old Java
   initialization section.

   #+BEGIN_SRC elisp
     (defun my-c-mode-hook ()
       (setq c-basic-offset 4)
       (c-set-offset 'substatement-open 0)   ; Curly braces alignment
       (c-set-offset 'case-label 4))         ; Switch case statements alignment

     (add-hook 'c-mode-hook 'my-c-mode-hook)
     (add-hook 'java-mode-hook 'my-c-mode-hook)
   #+END_SRC

** Ruby

   See my [[file:emacs-ruby.org][emacs-ruby.el]] file for details on working with Ruby.
   Typically, my [[file:emacs-local.org][emacs-local.el]] file would do the work of requiring
   this for particular hosts or projects.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-ruby)
   #+END_SRC

** Python

   See [[file:emacs-python.org][emacs-python.el]] for details on working with Python.
   Not sure if I should just load it directly, like:

   #+BEGIN_SRC elisp :tangle no
     (require 'init-python)
   #+END_SRC

** JavaScript

   See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

   #+BEGIN_SRC elisp
     (require 'init-javascript)
   #+END_SRC

** HTML, CSS and other Web Programming

   See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

   #+BEGIN_SRC elisp :tangle no
     (require 'init-web)
   #+END_SRC

* Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

* Tools
** Git

   I like [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]:

   #+BEGIN_SRC elisp
     (use-package git-gutter-fringe
        :ensure t
        :diminish git-gutter-mode
        :init (setq git-gutter-fr:side 'right-fringe)
        :config (global-git-gutter-mode t))
   #+END_SRC

   I want to have special mode for Git's =configuration= file:

   #+BEGIN_SRC elisp
     (use-package gitconfig-mode
       :ensure t)

     (use-package gitignore-mode
       :ensure t)
   #+END_SRC

   What about being able to see the [[https://github.com/voins/mo-git-blame][Git blame]] in a buffer?

   #+BEGIN_SRC elisp
     (use-package mo-git-blame
        :ensure t)
   #+END_SRC

   Run =mo-git-blame-current= to see the goodies.

** Magit

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   Don't believe me? Check out [[https://www.youtube.com/watch?v=vQO7F2Q9DwA][this video]].

   #+BEGIN_SRC elisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :init
       (defadvice magit-status (around magit-fullscreen activate)
         (window-configuration-to-register :magit-fullscreen)
         ad-do-it
         (delete-other-windows))
       :config
       (setq magit-branch-arguments nil
             ;; use ido to look for branches
             magit-completing-read-function 'magit-ido-completing-read
             ;; don't put "origin-" in front of new branch names by default
             magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
             magit-push-always-verify nil
             ;; Get rid of the previous advice to go into fullscreen
             magit-restore-window-configuration t)

       :bind ("C-x g" . magit-status))
   #+END_SRC

   I like having Magit to run in a /full screen/ mode, and add the
   above =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]].

   *Note:* Use the [[https://github.com/jwiegley/emacs-release/blob/master/lisp/vc/smerge-mode.el][smerge-mode]] that is now part of Emacs.

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

   #+BEGIN_SRC elisp
     (use-package markdown-mode
       :ensure t
       :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
       :config
       (bind-key "A-b" (surround-text-with "+*") markdown-mode-map)
       (bind-key "s-b" (surround-text-with "**") markdown-mode-map)
       (bind-key "A-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "s-i" (surround-text-with "*") markdown-mode-map)
       (bind-key "A-=" (surround-text-with "`") markdown-mode-map)
       (bind-key "s-=" (surround-text-with "`") markdown-mode-map))
   #+END_SRC

** PlantUML and Graphviz

   Install the [[http://www.graphviz.org/][Graphviz]] and [[http://plantuml.sourceforge.net/download.html][PlantUML]] projects using Homebrew:

   #+BEGIN_SRC sh :tangle no
     brew install graphviz
     brew link graphviz
     brew install plantuml
   #+END_SRC

   Load the [[https://github.com/wildsoul/plantuml-mode][mode for PlantUML]] and reference its jar:

   #+BEGIN_SRC elisp
     (let ((plantuml-jar (car (file-expand-wildcards "/usr/local/Cellar/plantuml/*/plantuml*.jar"))))
       (if plantuml-jar
           (use-package puml-mode
             :ensure t
             :commands (puml-mode)
             :init (progn
             (setq puml-plantuml-jar-path plantuml-jar
                   org-plantuml-jar-path plantuml-jar)))))
   #+END_SRC

   And the [[http://ppareit.github.com/graphviz-dot-mode/][mode for Graphviz]]:

   #+BEGIN_SRC elisp
     (use-package graphviz-dot-mode
        :ensure t)
   #+END_SRC

* Applications
** Web Browsing

   This section became involved, and has moved on to [[file:emacs-browser.org][emacs-browser]]
   file.

   #+BEGIN_SRC elisp
     (require 'init-browser)
   #+END_SRC

** EShell

   See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

   #+BEGIN_SRC elisp
     (require 'init-eshell)
   #+END_SRC

** Chatting

   Using the [[http://www.emacswiki.org/emacs/JabberEl][jabber.el]] project to connect up to Google Talk and what
   not. To begin, make sure you =brew install gnutls=

   #+BEGIN_SRC elisp
     (use-package jabber
       :ensure t
       :commands jabber-connect-all jabber-chat-with
       :init
       (define-key personal-global-map (kbd "a") 'jabber-connect-all)
       (define-key personal-global-map (kbd "j") 'jabber-chat-with)
       :config
       (setq starttls-use-gnutls t
             starttls-gnutls-program "gnutls-cli"
             starttls-extra-arguments '("--starttls" "--insecure")

             jabber-history-enabled t
             jabber-use-global-history nil
             jabber-backlog-number 40
             jabber-backlog-days 30)

       (defun my-jabber-chat-delete-or-bury ()
         (interactive)
         (if (eq 'jabber-chat-mode major-mode)
             (condition-case e
                 (delete-frame)
               (error
                (if (string= "Attempt to delete the sole visible or iconified frame"
                             (cadr e))
                    (bury-buffer))))))

       (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury))
   #+END_SRC

* Technical Artifacts

** Setting up the Exec Path

   Make sure that =PATH= variable for finding binary files can is the
   same as what Emacs will look for binary files. This little magic,
   starts up a shell, gets its path, and then uses that for the
   =exec-path=:

   #+BEGIN_SRC elisp
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
         (setenv "PATH" path-from-shell)
         (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

   Before we finish, we need to check if there is a local file for us
   to load and evaluate.  We assume the local file has been tangled
   and provides the =init-local= key:

   #+BEGIN_SRC elisp
     (require 'init-local nil t)
   #+END_SRC

   After the first load, we can reload this with a require:

   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Before you can build this on a new system, make sure that you put
   the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
